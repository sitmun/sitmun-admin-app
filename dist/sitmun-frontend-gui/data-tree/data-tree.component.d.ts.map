{"version":3,"file":"data-tree.component.d.ts","sources":["data-tree.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { FlatTreeControl } from '@angular/cdk/tree';\r\nimport { EventEmitter, ElementRef } from '@angular/core';\r\nimport { MatTreeFlatDataSource, MatTreeFlattener } from '@angular/material/tree';\r\nimport { BehaviorSubject, Observable } from 'rxjs';\r\nimport { SelectionModel } from '@angular/cdk/collections';\r\n/**\r\n * File node data with nested structure.\r\n * Each node has a name, and a type or a list of children.\r\n */\r\nexport declare class FileNode {\r\n    id: string;\r\n    children: FileNode[];\r\n    name: string;\r\n    type: any;\r\n    active: any;\r\n    cartographyId: any;\r\n    cartographyName: any;\r\n    datasetURL: any;\r\n    description: any;\r\n    filterGetFeatureInfo: any;\r\n    filterGetMap: any;\r\n    filterSelectable: any;\r\n    isFolder: any;\r\n    metadataURL: any;\r\n    order: any;\r\n    parent: any;\r\n    queryableActive: any;\r\n    radio: any;\r\n    tooltip: any;\r\n    _links: any;\r\n    status: any;\r\n}\r\n/** Flat node with expandable and level information */\r\nexport declare class FileFlatNode {\r\n    expandable: boolean;\r\n    name: string;\r\n    level: number;\r\n    type: any;\r\n    id: string;\r\n    status: string;\r\n    constructor(expandable: boolean, name: string, level: number, type: any, id: string, status: string);\r\n}\r\n/**\r\n * File database, it can build a tree structured Json object from string.\r\n * Each node in Json object represents a file or a directory. For a file, it has name and type.\r\n * For a directory, it has name and children (a list of files or directories).\r\n * The input will be a json object string, and the output is a list of `FileNode` with nested\r\n * structure.\r\n */\r\nexport declare class FileDatabase {\r\n    dataChange: BehaviorSubject<FileNode[]>;\r\n    get data(): any;\r\n    constructor();\r\n    initialize(dataObj: any, allNewElements: any): void;\r\n    /**\r\n     * Build the file structure tree. The `value` is the Json object, or a sub-tree of a Json object.\r\n     * The return value is the list of `FileNode`.\r\n     */\r\n    buildFileTree(arrayTreeNodes: any[], level: number, allNewElements: any): any;\r\n    deleteItem(node: FileNode, changedData: any): void;\r\n    deleteNode(nodes: FileNode[], nodeToDelete: FileNode): void;\r\n    setOrder(data: any[]): any[];\r\n    copyPasteItem(from: FileNode, to: FileNode, changedData: any): FileNode;\r\n    copyPasteItemAbove(from: FileNode, to: FileNode, changedData: any): FileNode;\r\n    copyPasteItemBelow(from: FileNode, to: FileNode, changedData: any): FileNode;\r\n    /** Add an item to to-do list */\r\n    getNewItem(node: FileNode): FileNode;\r\n    insertItem(parent: FileNode, node: FileNode, changedData: any): FileNode;\r\n    insertItemAbove(node: FileNode, nodeDrag: FileNode, changedData: any): FileNode;\r\n    insertItemBelow(node: FileNode, nodeDrag: FileNode, changedData: any): FileNode;\r\n    getParentFromNodes(node: FileNode, changedData: any): FileNode;\r\n    getParent(currentRoot: FileNode, node: FileNode): FileNode;\r\n}\r\n/**\r\n * @title Tree with flat nodes\r\n */\r\nexport declare class DataTreeComponent {\r\n    database: FileDatabase;\r\n    createNode: EventEmitter<any>;\r\n    createFolder: EventEmitter<any>;\r\n    emitNode: EventEmitter<any>;\r\n    emitAllNodes: EventEmitter<any>;\r\n    eventNodeUpdatedSubscription: Observable<any>;\r\n    eventCreateNodeSubscription: Observable<any>;\r\n    eventGetAllRowsSubscription: Observable<any>;\r\n    eventRefreshSubscription: Observable<any>;\r\n    private _eventNodeUpdatedSubscription;\r\n    private _eventCreateNodeSubscription;\r\n    private _eventGetAllRowsSubscription;\r\n    private _eventRefreshSubscription;\r\n    treeControl: FlatTreeControl<FileFlatNode>;\r\n    treeFlattener: MatTreeFlattener<FileNode, FileFlatNode>;\r\n    dataSource: MatTreeFlatDataSource<FileNode, FileFlatNode>;\r\n    expansionModel: SelectionModel<string>;\r\n    dragging: boolean;\r\n    expandTimeout: any;\r\n    expandDelay: number;\r\n    validateDrop: boolean;\r\n    treeData: any;\r\n    getAll: () => Observable<any>;\r\n    allNewElements: any;\r\n    dragNode: any;\r\n    dragNodeExpandOverWaitTimeMs: number;\r\n    dragNodeExpandOverNode: any;\r\n    dragNodeExpandOverTime: number;\r\n    dragNodeExpandOverArea: string;\r\n    emptyItem: ElementRef;\r\n    /** Map from flat node to nested node. This helps us finding the nested node to be modified */\r\n    flatNodeMap: Map<FileFlatNode, FileNode>;\r\n    /** Map from nested node to flattened node. This helps us to keep the same object for selection */\r\n    nestedNodeMap: Map<FileNode, FileFlatNode>;\r\n    constructor(database: FileDatabase);\r\n    ngOnInit(): void;\r\n    getElements(): void;\r\n    transformer: (node: FileNode, level: number) => FileFlatNode;\r\n    private _getLevel;\r\n    private _isExpandable;\r\n    private _getChildren;\r\n    hasChild: (_: number, _nodeData: FileFlatNode) => boolean;\r\n    /**\r\n     * This constructs an array of nodes that matches the DOM\r\n     */\r\n    visibleNodes(): FileNode[];\r\n    findNodeSiblings(arr: Array<any>, id: string): Array<any>;\r\n    handleDragStart(event: any, node: any): void;\r\n    handleDragOver(event: any, node: any): void;\r\n    handleDrop(event: any, node: any): void;\r\n    handleDragEnd(event: any): void;\r\n    /**\r\n     * The following methods are for persisting the tree expand state\r\n     * after being rebuilt\r\n     */\r\n    sortByOrder(data: any[]): void;\r\n    setOrder(data: any[]): any[];\r\n    rebuildTreeForData(data: any[]): void;\r\n    private getParentNode;\r\n    updateNode(nodeUpdated: any): void;\r\n    createNewFolder(newFolder: any): void;\r\n    createNewNode(newNode: any): void;\r\n    onButtonClicked(id: any, button: string): void;\r\n    emitAllRows(): void;\r\n    getAllChildren(arr: any): any[];\r\n    deleteChildren(arr: any): void;\r\n}\r\n"]}